<!DOCTYPE html>
<html lang="en">

<head>
	<title>Object viewer</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body style='margin: 0px'>


	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src='js/dat.gui.min.js'></script>
	<script src='js/GLTFLoader.js'></script>
	<script src='js/BufferGeometryUtils.js'></script>

	<!-- shaders -->

	<script type="text/x-glsl" id="vertex">
		attribute vec4 tangent;
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec3 wPosition;
		varying vec3 vTangent;
		varying vec3 vBitangent;
		varying vec2 vUv;

		void main() {
			vUv = uv;
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
			vNormal = normalMatrix * normal;
			vec3 objectTangent = vec3( tangent.xyz ); 
			vec3 transformedTangent = normalMatrix * objectTangent;
			vTangent = normalize( transformedTangent );
			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
			gl_Position = projectionMatrix * vPos;
		}
		</script>

	<script type="text/x-glsl" id="fragment">
			#ifdef USEAA
			#ifdef GL_ES
			#extension GL_OES_standard_derivatives : enable
			#ifdef GL_FRAGMENT_PRECISION_HIGH
			precision highp float;
			#else
			precision mediump float;
			#endif
			#endif
			#else
			#ifdef GL_ES
			precision mediump float;
			#endif
			#endif

			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vPosition;
			varying vec3 vBitangent;
			varying vec3 wPosition;
			varying vec2 vUv;
			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition1;
			uniform vec3 clight;
			vec3 cspec;
			vec3 cdiff;
			float roughness;
			uniform sampler2D specularMap;
			uniform sampler2D diffuseMap;
			uniform sampler2D roughnessMap;
			uniform sampler2D normalMap;
			uniform samplerCube irradianceMap;
			uniform vec2 normalScale;
			const float PI = 3.14159;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );
	
				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;
	
				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
	
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			void main() {
				vec3 normal = normalize( vNormal );
				vec3 tangent = normalize( vTangent );
				vec3 bitangent = normalize( vBitangent );
				mat3 vTBN = mat3( tangent, bitangent, normal );
				vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
				mapN.xy = normalScale * mapN.xy;
				vec3 n = normalize( vTBN * mapN );
				vec3 v = normalize( -vPosition);
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 irradiance = textureCube( irradianceMap, worldN).rgb;
				irradiance = pow( irradiance, vec3(2.2));
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
				n = perturbNormal2Arb( vPosition, normalize( vNormal ));  // interpolation destroys normalization, so we have to normalize
				v = normalize( -vPosition);
				vec3 h = normalize( v + l + l1);
				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float nDotl1 = max(dot( n, l1 ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float l1Doth = max(dot( l1, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
				float nDotv = max(dot( n, v ),0.000001);

				cdiff = texture2D( diffuseMap, vUv ).rgb;
				// texture in sRGB, linearize
				cdiff = pow( cdiff, vec3(2.2));
				// texture in sRGB, linearize
				cspec = pow( cspec, vec3(2.2));
				roughness = texture2D( roughnessMap, vUv).r; // no need to linearize roughness map

				vec3 fresnel = FSchlick(lDoth);
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*(GSmith(nDotv,nDotl)+GSmith(nDotv,nDotl1))*DGGX(nDoth,roughness*roughness)/
					(4.0*(nDotl+nDotl1)*nDotv);
				vec3 outRadiance = PI* clight * (nDotl+nDotl1) * BRDF * irradiance;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>

	<script>

		var renderer = new THREE.WebGLRenderer({ antialias: true });
		var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
		var controls = new THREE.OrbitControls(camera, renderer.domElement);
		var scene = new THREE.Scene();
		var lightParameters = {
			red: 1.0,
			green: 1.0,
			blue: 1.0,
			intensity: 1.0,
		}

		var textureParameters = {
			material: "DefaultMaterial",
			normalScale: 1.0
		}

		var envMap = {
			mappa: "1/",
			dummy_var: 0
		}

		var envLoader = new THREE.CubeTextureLoader();
		envLoader.setPath('envmap/' + envMap.mappa);

		var textureCube = envLoader.load([
			'px.png', 'nx.png',
			'py.png', 'ny.png',
			'pz.png', 'nz.png'
		]);

		scene.background = textureCube;
		textureCube.minFilter = THREE.LinearMipMapLinearFilter;

		// load irradiance map
		envLoader.setPath('envmap/irradiancemap/' + envMap.mappa);

		var irradianceMap = envLoader.load([
			'px.png', 'nx.png',
			'py.png', 'ny.png',
			'pz.png', 'nz.png'
		]);

		var diffuseMap = loadTexture("models/cat_statue/textures/" + textureParameters.material + "_BaseColor.jpeg");
		var roughnessMap = loadTexture("models/cat_statue/textures/" + textureParameters.material + "_metallicRoughness.png");
		var normalMap = loadTexture("models/cat_statue/textures/" + textureParameters.material + "_normal.jpeg");

		var uniforms = {
			cspec: { type: "v3", value: new THREE.Vector3(1.5, 1.5, 1.5) },
			cdiff: { type: "v3", value: new THREE.Vector3() },
			roughness: { type: "f", value: 0.5 },
			pointLightPosition: { type: "v3", value: new THREE.Vector3() },
			pointLightPosition1: { type: "v3", value: new THREE.Vector3() },
			clight: { type: "v3", value: new THREE.Vector3() },
			irradianceMap: { type: "t", value: irradianceMap },
			diffuseMap: { type: "t", value: diffuseMap },
			roughnessMap: { type: "t", value: roughnessMap },
			normalMap: { type: "t", value: normalMap },
			normalScale: { type: "v2", value: new THREE.Vector2(1.0, 1.0) }
		};

		vs = document.getElementById("vertex").textContent;
		fs = document.getElementById("fragment").textContent;

		ourMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs, });

		uniforms.pointLightPosition.value = new THREE.Vector3(7,7,7);
		uniforms.pointLightPosition1.value = new THREE.Vector3(-4.4,4.6,1.);

		var hemiLight = new THREE.HemisphereLight(0xffffff, 0x110101, 0.5);
		hemiLight.position.set(0, 128, 0);
		scene.add(hemiLight);

		var loader = new THREE.GLTFLoader().setPath('models/cat_statue/');
		loader.load('scene.gltf', function (gltf) {
			globalObject = gltf;
			oggetto = gltf.scene.children[0].children[0].children[0].children[0].children[0];
			oggetto.geometry.center();
			oggetto_mesh = new THREE.Mesh(oggetto.geometry, ourMaterial);
			oggetto_mesh.name = "gatto";
			THREE.BufferGeometryUtils.computeTangents(oggetto.geometry);
			scene.add(oggetto_mesh);
			// oggetto.children.forEach(function (item, index) {
			// });
			render();
		});

		function loadTexture(file) {
			var texture = new THREE.TextureLoader().load(file, function (texture) {

				texture.minFilter = THREE.LinearMipMapLinearFilter;
				texture.anisotropy = renderer.getMaxAnisotropy();
				texture.offset.set(0, 0);
				texture.needsUpdate = true;
				render();
			})
			return texture;
		}

		var gui;
		function init() {

			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.setClearColor(0xf0f0f0);

			camera.position.set(0, -0.1, 3.9);
			scene.add(camera);
			document.body.appendChild(renderer.domElement);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			controls.addEventListener('change', render);
			controls.minDistance = 1;
			controls.maxDistance = 100;
			controls.enablePan = false;
			controls.target.copy(scene.position);
			controls.update();

			window.addEventListener('resize', onResize, false);



		}

		function delete3DOBJ(objName) {
			var selectedObject = scene.getObjectByName(objName);
			scene.remove(selectedObject);
			render();
		}

		function onResize() {

			renderer.setSize(window.innerWidth, window.innerHeight);
			camera.aspect = (window.innerWidth / window.innerHeight);
			camera.updateProjectionMatrix();
			render();
		}

		function update() {
			requestAnimationFrame(update);
		}

		function render() {
			updateUniforms();
			renderer.render(scene, camera);
		}

		function clearGui() {

			if (gui) gui.destroy();
			gui = new dat.GUI();
			gui.open();

		}

		function buildGui() {

			clearGui();
			lightSettings = gui.addFolder('Light Parameters');
			lightSettings.add(lightParameters, 'red').min(0).max(1).onChange(function (newVal) { render() });
			lightSettings.add(lightParameters, 'green').min(0).max(1).onChange(function (newVal) { render() });
			lightSettings.add(lightParameters, 'blue').min(0).max(1).onChange(function (newVal) { render() });
			lightSettings.add(lightParameters, 'intensity').min(0).max(10000).onChange(function (newVal) { render() });

			textureSettings = gui.addFolder('texture parameters');
			textureSettings.add(textureParameters, 'material', ['DefaultMaterial', 'Rame']).onChange(
				function (newVal) {
					diffuseMap = loadTexture("models/cat_statue/textures/" + newVal + "_BaseColor.jpeg");
					
					roughnessMap = loadTexture("models/cat_statue/textures/" + newVal + "_metallicRoughness.png");
					normalMap = loadTexture("models/cat_statue/textures/" + newVal + "_normal.jpeg");
					if(newVal == "Rame"){
						uniforms.cspec.value = new THREE.Vector3(0.995,0.638,0.652);
					} else {
						uniforms.cspec.value = new THREE.Vector3(1.5,1.5,1.5);
					}
					ourMaterial.needsUpdate = true;
					render();
				});

			envSettings = gui.addFolder('Mappa');
			envSettings.add(envMap, 'mappa', ["1/", '2/']).onChange(
				function (newVal) {
					envLoader.setPath('envmap/' + newVal);
					textureCube = envLoader.load([
						'px.png', 'nx.png',
						'py.png', 'ny.png',
						'pz.png', 'nz.png'
					]);

					ourMaterial.needsUpdate = true;
					scene.background = textureCube;
					textureCube.minFilter = THREE.LinearMipMapLinearFilter;
					envLoader.setPath('envmap/irradiancemap/' + newVal);
					irradianceMap = envLoader.load([
						'px.png', 'nx.png',
						'py.png', 'ny.png',
						'pz.png', 'nz.png'
					]);
					setTimeout(render, 0);
				});
		}

		function updateUniforms() {
			uniforms.clight.value = new THREE.Vector3(
				lightParameters.red * lightParameters.intensity,
				lightParameters.green * lightParameters.intensity,
				lightParameters.blue * lightParameters.intensity);
			uniforms.diffuseMap.value = diffuseMap;
			uniforms.roughnessMap.value = roughnessMap;
			uniforms.normalMap.value = normalMap;
			uniforms.normalScale.value = new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale);
			uniforms.irradianceMap.value = irradianceMap;
		}

		init();
		buildGui();
		update();
		render();

	</script>
</body>

</html>